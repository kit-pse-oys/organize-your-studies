# docker-compose: Initialisiert die einzelnen Container durch die Spezifikationen gegeben durch
# die entsprechenden DockerFiles und Umgebungsvariablen.
# docker compose --env-file .env.local up --build für lokale Entwicklung
# docker compose --env-file .env up --build für Deployment
# docker compose down --volumes --remove-orphans stoppt und entfernt alle Container, Netzwerke und Volumes (cleanup)
# Author: uhupo
services:
  db:
    image: postgres:15
    container_name: oys-postgres-db
    environment:
      - POSTGRES_DB=${DB_NAME:-oys_db}
      - POSTGRES_USER=${DB_USER:-postgres}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    networks:
      - oys-network

  java-server:
    build: ./java-server
    container_name: oys-java-server
    ports:
      - ${SERVER_PORT}:${SERVER_PORT}   # Macht den Server unter den Port erreichbar
    environment:
      # Diese Variablen überschreiben die Werte in application.properties
      - SPRING_DATASOURCE_URL=jdbc:postgresql://${DB_HOST:-db}:${DB_PORT:-5432}/${DB_NAME:-oys_db}
      - SPRING_DATASOURCE_USERNAME=${DB_USER:-postgres}
      - SPRING_DATASOURCE_PASSWORD=${DB_PASSWORD}
      - SPRING_JPA_HIBERNATE_DDL_AUTO=update
      - SPRING_SSL_KEYSTORE_PASSWORD=${SSL_KEYSTORE_PASSWORD}
    depends_on:
      - db  # Wartet, bis der Datenbank-Container gestartet ist
      - python-microservice # Wartet, bis der Python-Microservice-Container gestartet ist
    networks:
      - oys-network
    volumes:
      - ${SSL_KEYSTORE_PATH}/keystore.p12:/keystore/keystore.p12:ro

  python-microservice:
    build: ./python-microservice
    container_name: oys-python-microservice
    # Keine Ports nach außen, da nur der Java-Server zugreift
    networks:
      - oys-network

networks:
  oys-network:
    driver: bridge